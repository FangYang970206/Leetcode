# 问题描述

给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。

# 例子

```bash
输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

# 方法

递归思路挺清楚的，使用循环遍历（0... n), 选取i作为根节点（1 <= i <= n), 其中(0,i-1)一定在左子树,(i+1, n]一定在右子树,然后在对左子树和右子树进行相同的划分操作，最后自底向上进行汇总。

还有一种思路是动态规划，利用的是已知（1...n-1), 对于n来说，n要不在根节点，要么就在右节点，且该右节点无右孩子，通过遍历得到最后的结果。思路来自于https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-2-7/ 的第四种解法。java解法双100%
