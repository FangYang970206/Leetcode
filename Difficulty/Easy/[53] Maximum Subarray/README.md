# 问题描述
给定整数数组nums，找到具有最大和的相邻子数组(至少包含一个数字)并返回其和。

# 例子
```bash
Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```

# 方法
参考编程珠玑这本书的第八章。
- $O(n^3)$算法1：外两层循环确定计算的索引$[i,j]$，内循环计算$[i,j]$相加的数。暴力穷举！
- $O(n^2)$算法2a：外循环左区间，内循环有区间，但$sum$是在两种循环之间初始化，左区间不动，右区间移动可以逐次累加，每次累加进行$max$函数。
- $O(n^2)$算法2b：先用一个循环计算累加和，得到一个数组，每个数组的第$i$个元素包含$nums[0..i]$中各个数的累加和。然后跟上面算法1一样，两层循环，不过$[i, j]$的元素求和可以用第一步求出的数组的第$j$位减去第$i-1$位.
- $O(nlog(n))$算法3：将原始问题进行分而治之，要么最优解出现在分开的两边，要么出现在交集的地方，取三个最大的值即可。交集的地方一定是从中间同时往两边累加最大的数求和，分开的两边又可以再分，问题一样，进行不断递归。最后小向量的处理方式是与$0$进行$max$函数的比较。
- $O(n)$扫描算法：这个方法简单，但并不容易想到，假设我们已经解决了$x[0..i-1]$的问题，如何解决$x[0..i]$的问题，类似分治思想，有两种情况，一种是最大总和子数组在前$i-1$个元素中，或者其结束位置在第$i$个元素中。这里结合了算法3和算法2b的思想，不重头计算前i个的最大子向量，而是利用结束位置为i-1的最大子向量。

扫描算法c++实现如下：
```c++
int maxsofar = 0;
int maxendinghere = 0;
for (auto &num: nums){
    maxendinghere = max(maxendinghere + num, 0);
    maxsofar = max(maxsofar, maxendinghere);
}
return maxsofar;
```
